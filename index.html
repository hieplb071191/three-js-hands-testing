<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Hand Gesture Mobile</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; position: fixed; width: 100%; height: 100%; }
    canvas { display: block; }

    /* Khung Camera nh·ªè t·ªëi ∆∞u cho Mobile */
    #webcam-container {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 120px; /* Nh·ªè h∆°n tr√™n mobile */
      height: 160px;
      border: 2px solid #00ff88;
      border-radius: 8px;
      overflow: hidden;
      z-index: 10;
    }

    #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

    /* B·∫£ng th√¥ng tin g·ªçn nh·∫π */
    #info {
      position: absolute; bottom: 30px; left: 0; right: 0;
      text-align: center; color: white; z-index: 100;
      pointer-events: none;
    }

    .status-badge {
      display: inline-block;
      background: rgba(0, 255, 136, 0.2);
      backdrop-filter: blur(5px);
      border: 1px solid #00ff88;
      padding: 10px 20px;
      border-radius: 30px;
      font-family: sans-serif;
    }

    h2 { margin: 0; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 1px; }
  </style>
</head>
<body>

  <div id="info">
    <div class="status-badge">
      <h2 id="gesture-text">ƒêang kh·ªüi ƒë·ªông...</h2>
    </div>
  </div>

  <div id="webcam-container">
    <video id="webcam" autoplay playsinline></video>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    const videoElement = document.getElementById('webcam');
    const gestureText = document.getElementById('gesture-text');

    // --- THREE.JS OPTIMIZATION ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); // T·∫Øt antialias ƒë·ªÉ m∆∞·ª£t h∆°n tr√™n mobile
    renderer.setPixelRatio(window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio); // Gi·ªõi h·∫°n pixel ratio ƒë·ªÉ nh·∫π GPU
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.IcosahedronGeometry(1.2, 1);
    const material = new THREE.MeshStandardMaterial({ color: 0x00ff88, wireframe: true });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 2);
    scene.add(light);

    camera.position.z = 4;

    // --- GESTURE LOGIC ---
    function detectGesture(landmarks) {
      const getDist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
      
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const indexPip = landmarks[6];
      const middleTip = landmarks[12];
      const middlePip = landmarks[10];
      const ringTip = landmarks[16];
      const pinkyTip = landmarks[20];

      // Victory: Tr·ªè v√† Gi·ªØa du·ªói (y c·ªßa tip th·∫•p h∆°n pip), c√°c ng√≥n kh√°c g·∫≠p
      const isVictory = indexTip.y < indexPip.y && middleTip.y < middlePip.y && ringTip.y > landmarks[14].y;
      
      // Thumbs Up: Ng√≥n c√°i cao h∆°n h·∫≥n c√°c ng√≥n kh√°c
      const isThumbsUp = thumbTip.y < landmarks[2].y && indexTip.y > indexPip.y;

      if (isVictory) return "VICTORY ‚úåÔ∏è";
      if (isThumbsUp) return "LIKE üëç";
      return "TRACKING...";
    }

    // --- MEDIAPIPE OPTIMIZATION ---
    function onResults(results) {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const gesture = detectGesture(results.multiHandLandmarks[0]);
        gestureText.innerText = gesture;

        if (gesture.includes("VICTORY")) {
          mesh.rotation.y += 0.1;
          mesh.material.color.setHex(0x00ffff);
        } else if (gesture.includes("LIKE")) {
          mesh.scale.set(1.5, 1.5, 1.5);
          mesh.material.color.setHex(0xff0055);
        } else {
          mesh.scale.set(1, 1, 1);
          mesh.material.color.setHex(0x00ff88);
          mesh.rotation.y += 0.02;
        }
      }
      renderer.render(scene, camera);
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 0, // 0 = Nhanh h∆°n, 1 = Ch√≠nh x√°c h∆°n (Ch·ªçn 0 cho mobile)
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({ image: videoElement });
      },
      width: 480, height: 640 // T·ªâ l·ªá d·ªçc cho mobile
    });
    cameraUtils.start();

    // Responsive
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>